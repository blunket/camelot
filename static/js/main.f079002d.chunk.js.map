{"version":3,"sources":["pieces/BlackKnight.png","pieces/WhiteKnight.png","pieces/BlackPawn.png","pieces/WhitePawn.png","img/castle.png","functions.js","Game.js","Board.js","App.js","serviceWorker.js","index.js"],"names":["module","exports","isMyPiece","props","gridID","G","cells","pieces","WHITE_KNIGHT","WHITE_PAWN","playerID","BLACK_KNIGHT","BLACK_PAWN","isInOwnCastle","canCaptureOutOfOwnCastle","canCapture","grid","i","basicOffsets","length","adjacentGridID","adjacentCellContent","myCol","adjacentCol","Math","abs","jumpDestGridID","jumpDestCellContent","jumpDestCol","getCellInfo","chosenPiece","isDarkSquare","cellContent","row","floor","col","isSelected","isLegalOption","isJumpOption","capturedGridID","moveType","chosenCellContent","chosenCol","isBasicMove","mustLeaveCastle","whiteCastleMoves","blackCastleMoves","canCaptureThisTurn","movingPieceGridID","jumpPositions","includes","CamelotGame","Game","setup","Array","fill","disabledCells","blackKnights","blackPawns","whiteKnights","whitePawns","getCellsSetup","moves","movePiece","ctx","pieceGridID","destinationGridID","mustCaptureError","mockProps","currentPlayer","destCellInfo","pieceToMove","push","capturesThisTurn","canStartCharge","missedKnightsCharge","submitTurn","canEndTurn","captureOutOfCastle","movingPiece","events","endTurn","flow","endPhase","onTurnBegin","gridLength","canCaptureScan","canCaptureOutOfCastleThisTurn","onTurnEnd","wcA","wcB","bcA","bcB","blackPieces","whitePieces","endGame","winner","countBlackPieces","filter","obj","countWhitePieces","CamelotBoard","state","cellLabels","manualFlipBoard","this","setState","undo","cellInfo","moving","bg","evenColor","oddColor","chosenColor","legalColor","isMyTurn","textAlign","verticalAlign","position","width","cellSize","height","backgroundColor","outline","zIndex","cursor","_this2","amISpectating","tbody","_loop","j","react_default","a","createElement","key","style","gridColLetter","gridRowNumber","pieceImg","alt","pieceStyle","src","BlackKnight","WhiteKnight","BlackPawn","WhitePawn","castleStyle","CastleIcon","label","labelStyle","getCellStyle","onClick","reverse","messageDiv","gameover","messageDivStyle","whoseTurnDiv","marginTop","gameWrapStyle","cellSpacing","id","buttonsStyle","toggleLabelsStyle","canSubmit","buttonsDiv","undoClick","undoStyle","disabled","submitTurnClick","submitTurnButtonStyle","margin","reset","React","Component","display","flexDirection","alignItems","justifyContent","padding","fontWeight","border","borderRadius","top","left","fontSize","color","fontFamily","CamelotClient","Client","game","board","debug","process","multiplayer","server","App","BrowserRouter","Route","path","exact","render","Link","to","Boolean","window","location","hostname","match","ReactDOM","src_App","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.f079002d.chunk.js","sourcesContent":["module.exports = \"data:image/png;base64,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\"","module.exports = \"data:image/png;base64,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\"","module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADwAAAA8CAYAAAA6/NlyAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAN1wAADdcBQiibeAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAKaSURBVGiB7Zo9axVBFIafNyYoGhSNYFDUoI1CGtEgooIo/oGAhWApWlhoivgLgp32tlqJBEEsBMXGr0ILkYiVhRaCICL4gUXisbi5QaIkOzvnzL25975wujnvnIezOzs7uzIzukl9rS6gtHrAna4ecKerB9zp6jrg/lZMKmknMAbsAF4DL83sa5HJzaxYACPAA8AWxSxwBVgdXYNKbS0lHQbuA4NLDJsBDpnZ96g6itzDkgaBGywNCzAKXI2spdSiNQnsqjj2nKR9UYWUAj4SPL6ySgGndmzFd/hn8PjKKgX8Jnh8ZZUCvpMw9jdwN6qQcGBJJ4GphJQ+YFrSlpB6IjcekvYAL1j++fs/PQaOm9msZ01hHZY0AExTDxbgKI3tpqvCOizpDHAz0+YXsN3MPjuUBMTewxcdPNYA5x18FhQCLGkDcMDJ7oSTDxDX4ar75ira7egVBrzN0WtYkrzMooDfOnrNmOPKGgJsZu+AT052z518gNhV+qmTzzMnHyAW+JGDxxzwxMFnQZHA12lsD3N02cw+eBSzoOBTymHgI/+eUlaJmxE1Re6l1wIXgE01LY5JOuVYUkNBnd0LvKdeZxfHPRzPqyNgtzrCNuMW8y86bQUMrAdeOcM241pbAQMDwMMg2GZMtBPwVDCs0TjvGms5MI1TjS8FgA24nVOr12PpLLDRyWs5jUuq/cqYDSypH7iU65OgPmCidrbD5XyaMpfy3/EDGGrVJT3p4JGq5i4uWVnAkkYI/PC1jMbrJOV2+GBmfo5GJa1LTVrJwKuA/alJucCjmfm5Sp4/F3goMz9XyfP3gBO1OTM/V8nz1wae/zqYvEo6K3k7m/Pr4RytewY39S01odifeO2irvubtgfc6eoBd7q6DvgP/gH4mMhDFawAAAAASUVORK5CYII=\"","module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADwAAAA8CAYAAAA6/NlyAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAN1wAADdcBQiibeAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAASLSURBVGiB7ZrLS2NnGIefL6YJEuM4GaOiUvDCgJIKI0Y7KFJ3BSm00j9gil1ULbRi+1cUV92U7gahSLvUzeAiVG3QCoOggxmvgRlRY2uKSLSivl3oV2JJgyfnYrw8EDgh3+X35P3ycc7JUSLCXcJ13QGc5l74tnMvfNu5F77t3Dlh93VMqpQKAmGgEVgGfheRbUcmFxHHXkAx8CMgGV4/AaV2Z1BOnVoqpaqAKPCux+Ohra2NUChELBZjZmaGw8NDgF2gXURWbAviYHVfANLS0iJLS0uSTjwel87OTl3pKFBgWw6HZD8BJBAIyNbWlmQimUxKZWWllv7MrixO7dIdAAMDA1RUVGRsUFJSwtDQ0KX2duCU8BOAcDictVHa50/sCuKUcArg5OQka6PT01N9eGRXEKeEXwFMTExkbRSJRPRhzLYkDm1a7wPi8XgkHo9n3LR2d3fF7/frTevDG7tpKaUeA88BPB4P8Xg8Y7u3b9/idv974veDUsqe37HNlS0GXgMSCoUkFotlrK5mY2NDwuGwrvImUGZ5JpuFfwakqalJDg4Osspqjo6OpKOjQ0tP3Bhhzi8MpKioSNbW1q4kq0kkElJaWqqlO6zMZedv+EuA3t5eamtrDXUMBoP09/frt19ZmsrGCq8DMj8/b6i6ms3NTV3hPStz2XK1pJRyA0cul6sglUrh9XpzGicQCJBMJgECIpK0IptdS7oMKCgpKclZFs6FL6iyIhRg65L+A5CNjY2clvTe3p4opQQ4BgqtymXnpjUDMD09nVPnaDSqv7iXInJoVSg7haMAk5OTOXWemprSh79ZlOccG5d0OyBer1dmZ2cNLedYLCbFxcV6l/7I0lx2CV9Ifw9IdXW17OzsXEl2f39fGhoatOwvlmeyWdgNRADp7OyU4+PjrLJnZ2fS09OjZReBohsjzPn+8AXwJyBut1vGxsayCkejUfF6vVr4L+BrwJ33wsBDYPYiuHR1dcni4mJWWc3q6qp0d3en369eACryVhjwAr8CUlVVJaOjo1cS/S/j4+NSV1enpV8C/rwTBhQwqjeqN2/e5CSrSSQSUl9fr6VfAO/km/B3gDx48EAWFhZMyWpWV1elrKxMSz/PG2Ggh4v7VpFIxBJZzdzcnPh8Pi39eb4IzwEyPDxsqaxmZGREC78GXNcqDHzAxV8pV72VY5STkxOpqanR0h/nmtWqc+lv4PyvFJ/PZ9GQlykoKGBwcPDSfDlhQXUbgbPCwkJJJBK2VFdzcHAggUBAV/npdVV4CFDPnj0jGAxaMNz/4/P56Ovr02+/zWkQCyq8A8jy8rKt1dVsb2+Ly+US4G/AazivSdk6QCorKx2R1TQ2Nupl3WY0s9kl/RSgtbXV5DDGSJuvzWhfs8LvATQ3N5scxhhp84WM9jUrXApQXl5uchhjpM33yGhfs8KP4NLtVEdIm8+wsKkb8UqpaaC9trYWv9+f8zhGSaVSrKysALwSEUPL2uyTeA8B1tfXTQ5jbn4jmBX+lPML/usi+0MjGXDsSbx84c49TXsvfNu5F77t3DnhfwDnGIncxPZT9AAAAABJRU5ErkJggg==\"","module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAH8AAAB1CAYAAABnJj51AAAABHNCSVQICAgIfAhkiAAABm5JREFUeJztnU2IFEcYhp/98WeJQXNQEtSQBENEXMSom0RELyFoEA8KQkARcjEeZREC4iEQ8SgeN8JeRHIIIpKA0b0M0YuJfwRjIoLZKBsEg7oRA6u7OzlUN64zXT3dPVVd1VPfA99Bma556nuXnene6uoezNMDfAysBP4CJi28R0jMBT4F3kT1s+5WJ51hlGAdOI/6YRCK0YPqYdzPYbc66WzghWhcu5waVZtdNPdzg1OjFM7SLPsb0OVSqqJ0oXrX2M+zLqV0rKFZNK7tDr2qynb0/Vzj0CuRU+hlrzj0qipX0PfzlEOvJlYA0+hl68BmZ3bVYzPpvZxG9dwLTpAuWwcuOLOrHhdo3c8Tzuxm8A7qXL6VbB3Y6MixSmwkWy8nUb13yhDZZOvAOUeOVeIc2fs55MgRgMXARIJUWq1zYloN1pGvlxOoDJxwNINgY512YloNTpO/n0ddiC4EnhaQnUZd9xdeZiWtz5iS6ikqi1I5XEA0rpNly1aAkxTv5+EyRecD423ITgLLyhT2nGVkP2NKqnFUJqVwsA3RuI6XJVsBjtN+Pw+WIfoK8MCA7ASwpAxhz1lC/jOmpHqAysYq+w2IxnXMtmwFOIa5fu63KToHGDMo+x+wyKaw5yxC9cBUP8dQGVlhr0HRuI7Ykq0ARzDfz702RHuBOxZk/wUW2BD2nAWouZvu5x1UVkbZbUE0rkOmZSvAIez1c7dJ0W7gpkXZf4B5JoU9Zx5qzrb6eROVmRF2WBSNa9CUbAUYxH4/d5iSvVqC7N+oNeqdzlzUXG3386oJ2S0liMa1z4Sw5+yjvH5uaVf2Yomyo1j4puoRvag5ltXPi+3IbipRNK497Qh7zh7K7+emorIzbxUqq/7A4DdVj+hGza3sfo4UkR1wIBrXziLCnrMTd/0cyCt7xqHs9byyFeA67vp5Jo9oP8WWFJmsrXmEPWcrbns5jcr0JXSfrXtxf3PlF47f3ySu59JFwh98dOG/YdclEz44mMKHuTQ56MIfxv2OGt84fn+TuJ7LJAkbO6T9al+JunVoti0jDVPAz8Clkt/XNh+gvnWXvVPJM+An4EbJ7ysIgiAIgiAIglNWAN8BD4HHCXUXtcQ4bT34IHBLc/wj4EdgfQuPL4HbbY7hA+tRro9Instt1Fx1zAK+Ru22mXT8Q1ReaXvyzEFldrfFGPxAtuvDus0U12Y8/nf01xWSNm9Mqiqcq94g21x0myl+lvH4tF1OkjZvTCqmMr5Qd1t1niXI72rGyHO799KUSbtmKdnnobutOuut2tPoL8BlGqOb7AsndFem8lyxsjmGD5TZiy702WUaoxNXzAgZkfADRsIPGAk/YCT8gJHwAyZP+P007/jUC3yYY4yPEv5vNgWWFncAAzSfp79Kvj0Kk/o5n4TFmkl0EV3pqRBvo2558pG3gD9dS2RFfu0HjIQfMBJ+wHTjfol2Xp67FkjBZ7cmuoHvXUvk4BpqrzlfGUM5VoIe4BfUtp2vobYGG4+qD3cbJUwB92a4PEb9/foAcN+RU1YuoXo5jxf+46jTOFcfsxOoH8zY5REtntBVo/0bBIvWaPvz9Y5R3PWzliQkX/gCRsIPGAk/YCT8gJHwA0bCD5iqbXi4GP1jxMZQjxppxetRJXGfbNcRFqJ/mOED/L4QlYka/pzn96CuRKbdY/CM1o8X/Zb0p1hNRq9JYyh6L90YU5Fr4/Lp0QJ9sHqen0bNoexog8u2HMeu0swn6wOK6+gf+LwqxxjbGo4dLaFvucKvymf++zleu9rAGLrX6sZu9/2cUJXwBQtI+AEj4QeMhB8wEn7A+HqRpw/YPOPfeZ643d9wbMzyHGMs14yRaT18xLKGMfpyHOucGu7OS6XkPF+wiYQfMBJ+wEj4ASPhB4yEHzASfsBI+AEj4QeMhB8wEn7ASPgBI+EHjIQfMBJ+wEj4ASPhB4yEHzASfsD4uoDTJreA88DlqEA9IWwt8AnwniMvr6jhfuGhyXoOfIV6bp2OWdFrnnvga30BZxo1D6RN1T3y3WS5OjrGtbfV8EP5zP+cfDtjXouO6WhCCH8IGClw3AitN3uoNJ0e/jPUlq1FORCN0ZF0evi/Ak/aOP5JNEZH0unhX279klLG8JJOD/+qJ2N4SaeH386vfJNjeEmnhy+kIOEHjIQfMBJ+wEj4ASPhB4yEHzASfsBI+AEj4QfM/3Z1j7N19dd5AAAAAElFTkSuQmCC\"","import { pieces } from './Game.js'\nimport { basicOffsets } from './Game.js'\n\nexport function isMyPiece(props, gridID) {\n    switch (props.G.cells[gridID]) {\n        case pieces.WHITE_KNIGHT:\n        case pieces.WHITE_PAWN:\n            return props.playerID === \"0\"\n        case pieces.BLACK_KNIGHT:\n        case pieces.BLACK_PAWN:\n            return props.playerID === \"1\"\n        default:\n            return false;\n    }\n}\n\nexport function isInOwnCastle(props) {\n    if (props.playerID === \"0\") {\n        return isMyPiece(props, 185) || isMyPiece(props, 186);\n    } else {\n        return isMyPiece(props, 5) || isMyPiece(props, 6);\n    }\n}\n\nexport function canCaptureOutOfOwnCastle(props) {\n    if (props.playerID === \"0\") {\n        if (isMyPiece(props, 185) && canCapture(props, 185)) {\n            return true;\n        }\n        if (isMyPiece(props, 186) && canCapture(props, 186)) {\n            return true;\n        }\n    } else {\n        if (isMyPiece(props, 5) && canCapture(props, 5)) {\n            return true;\n        }\n        if (isMyPiece(props, 6) && canCapture(props, 6)) {\n            return true;\n        }\n    }\n    return false;\n}\n\n// Returns true if the piece at the given gridID is able to make any captures.\nexport function canCapture(props, gridID) {\n    let grid = props.G.cells;\n    if (grid[gridID] === null) {\n        return false;\n    }\n    if (gridID === 5 || gridID === 6) { // pieces cannot leave the enemy castle, not even for capturing.\n        if (grid[gridID] === pieces.WHITE_KNIGHT || grid[gridID] === pieces.WHITE_PAWN) {\n            return false;\n        }\n    } else if (gridID === 185 || gridID === 186) { // pieces cannot leave the enemy castle, not even for capturing.\n        if (grid[gridID] === pieces.BLACK_KNIGHT || grid[gridID] === pieces.BLACK_PAWN) {\n            return false;\n        }\n    }\n    for (var i = 0; i < basicOffsets.length; i++) {\n        let adjacentGridID = gridID + basicOffsets[i];\n        let adjacentCellContent = grid[adjacentGridID];\n        let myCol = gridID % 12;\n        let adjacentCol = adjacentGridID % 12;\n        if (Math.abs(myCol - adjacentCol) > 2) { // don't loop over the sides\n            continue;\n        }\n        if (adjacentCellContent !== null && !isMyPiece(props, adjacentGridID)) {\n            let jumpDestGridID = gridID + (2 * basicOffsets[i]);\n            let jumpDestCellContent = grid[jumpDestGridID];\n            let jumpDestCol = jumpDestGridID % 12;\n            if (Math.abs(jumpDestCol - adjacentCol) > 2) { // don't loop over the sides here either\n                continue;\n            }\n            if (jumpDestCellContent === null) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\n// Returns true if the current player is able to make *any* basic captures.\nexport function canCaptureScan(props) {\n    let grid = props.G.cells;\n    for (var gridID = 0, gridLength = grid.length; gridID < gridLength; gridID++) {\n        if (grid[gridID] === null || grid[gridID] === false || !isMyPiece(props, gridID)) {\n            continue;\n        }\n        if (canCapture(props, gridID)) {\n            return true;\n        }\n    }\n    return false;\n}\n\nexport function getCellInfo(props, chosenPiece, gridID) {\n    let isDarkSquare = false;\n    let cellContent = props.G.cells[gridID];\n    let row = Math.floor(gridID / 12);\n    let col = gridID % 12;\n\n    if (row % 2 === 0) {\n        isDarkSquare = col % 2 === 0;\n    } else {\n        isDarkSquare = col % 2 === 1;\n    }\n    let isSelected = gridID === chosenPiece;\n    let isLegalOption = false;\n    let isJumpOption = false;\n    let capturedGridID = false;\n    if (chosenPiece !== null && !isSelected) {\n        for (var i = 0; i < basicOffsets.length; i++) {\n            if (cellContent !== null) {\n                continue;\n            }\n            if (props.G.moveType === 'Basic') {  // if we've already made a basic move, it should be the only move on this turn at all.\n                break;\n            }\n            let chosenCellContent = props.G.cells[chosenPiece];\n            let adjacentGridID = chosenPiece + basicOffsets[i];\n            let adjacentCellContent = props.G.cells[adjacentGridID];\n            let chosenCol = chosenPiece % 12;\n            let adjacentCol = adjacentGridID % 12;\n            if (Math.abs(chosenCol - adjacentCol) > 2) { // don't loop over the sides...\n                continue;\n            }\n            let isBasicMove = gridID === chosenPiece + basicOffsets[i];\n            if (props.G.mustLeaveCastle) {\n                if (props.playerID === \"0\") {\n                    if (chosenPiece !== 185 && chosenPiece !== 186) {\n                        continue;\n                    }\n                    if (adjacentGridID === 185 || adjacentGridID === 186) {\n                        continue;\n                    }\n                } else {\n                    if (chosenPiece !== 5 && chosenPiece !== 6) {\n                        continue;\n                    }\n                    if (adjacentGridID === 5 || adjacentGridID === 6) {\n                        continue;\n                    }\n                }\n            }\n            if (chosenPiece === 5 || chosenPiece === 6) { // pieces cannot leave the enemy castle for any reason, even capturing.\n                if (chosenCellContent === pieces.WHITE_KNIGHT || chosenCellContent === pieces.WHITE_PAWN) {\n                     // they can, however, move within the castle, twice per game.\n                    if (props.G.whiteCastleMoves >= 2) {\n                        continue;\n                    }\n                    if (adjacentGridID !== 5 && adjacentGridID !== 6) {\n                        continue;\n                    }\n                }\n            } else if (chosenPiece === 185 || chosenPiece === 186) { // pieces cannot leave the enemy castle for any reason, even capturing.\n                if (chosenCellContent === pieces.BLACK_KNIGHT || chosenCellContent === pieces.BLACK_PAWN) {\n                     // they can, however, move within the castle\n                    if (props.G.blackCastleMoves >= 2) {\n                        continue;\n                    }\n                    if (adjacentGridID !== 185 && adjacentGridID !== 186) {\n                        continue;\n                    }\n                }\n            }\n\n            if (isBasicMove && (props.G.mustLeaveCastle || !props.G.canCaptureThisTurn)) {\n                if (props.G.movingPieceGridID !== null) { // if we've already moved this turn, we cannot make a basic move now\n                    continue;\n                }\n                if (props.playerID === \"0\") { // neither player may make a Basic move into their own castle for any reason\n                    if (gridID === 185 || gridID === 186) {\n                        continue;\n                    }\n                } else {\n                    if (gridID === 5 || gridID === 6) {\n                        continue;\n                    }\n                }\n                if (props.G.mustLeaveCastle && canCaptureOutOfOwnCastle(props)) {\n                    continue;\n                }\n                isLegalOption = true;\n            }\n            if (adjacentCellContent !== null && gridID === chosenPiece + (2 * basicOffsets[i])) {\n                let jumpDestCol = (chosenPiece + (2 * basicOffsets[i])) % 12;\n                if (Math.abs(jumpDestCol - adjacentCol) > 2) { // don't loop over the sides here either...\n                    isLegalOption = false;\n                    continue;\n                }\n                isLegalOption = true;\n                isJumpOption = true;\n                if (isMyPiece(props, adjacentGridID)) {\n                    // don't allow jumping if we're not already jumping, unless it's the first jump.\n                    // also, don't allow jumping onto a square we've already jumped on.\n                    if ((props.G.moveType !== false && props.G.moveType !== 'Jumping') || props.G.jumpPositions.includes(gridID)) {\n                        isLegalOption = false;\n                        isJumpOption = false;\n                        continue;\n                    }\n                } else {\n                    if (props.G.moveType === false || props.G.moveType === 'Capturing') {\n                        // any piece is allowed to start capturing as the first move of the turn, or as a continuation\n                        capturedGridID = adjacentGridID;\n                    } else {\n                        // or, knights may capture right after jumping\n                        if (chosenCellContent === pieces.WHITE_KNIGHT || chosenCellContent === pieces.BLACK_KNIGHT) {\n                            if (props.G.moveType === 'Jumping') {\n                                isLegalOption = true;\n                                isJumpOption = true;\n                                capturedGridID = adjacentGridID;\n                            }\n                        } else {\n                            isLegalOption = false;\n                            isJumpOption = false;\n                            continue;\n                        }\n                    }\n                }\n                // if we can make a capture, and we're merely jumping, undo making this jump legal (except for a knight who might be able to make a power play)\n                // also, if this is a jump and not a capture, disallow jumping into own castle\n                if (capturedGridID === false) {\n                    if (props.G.canCaptureThisTurn || props.G.mustLeaveCastle) {\n                        if (!(chosenCellContent === pieces.WHITE_KNIGHT || chosenCellContent === pieces.BLACK_KNIGHT)) {\n                            isLegalOption = false;\n                            isJumpOption = false;\n                        }\n                    }\n                    if (props.playerID === \"0\") {\n                        if (gridID === 185 || gridID === 186) {\n                            isLegalOption = false;\n                            isJumpOption = false;\n                        }\n                    } else {\n                        if (gridID === 5 || gridID === 6) {\n                            isLegalOption = false;\n                            isJumpOption = false;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    return {\n        isDarkSquare: isDarkSquare,\n        cellContent: cellContent,\n        isSelected: isSelected,\n        isLegalOption: isLegalOption,\n        isJumpOption: isJumpOption,\n        capturedGridID: capturedGridID,\n        isMyPiece: isMyPiece(props, gridID),\n        row: row,\n        col: col,\n    }\n}\n","import { Game } from 'boardgame.io/core';\nimport { isMyPiece, getCellInfo, isInOwnCastle, canCaptureOutOfOwnCastle, canCapture, canCaptureScan } from './functions.js';\n\nconst pieces = {\n    BLACK_KNIGHT: 'BK',\n    BLACK_PAWN: 'BP',\n    WHITE_KNIGHT: 'WK',\n    WHITE_PAWN: 'WP',\n};\n\nconst basicOffsets = [\n    -12, // up\n    12,  // down\n    -1,  // left\n    1,   // right\n    -11, // up right\n    -13, // up left\n    13,  // down right\n    11,  // down left\n];\n\nfunction getCellsSetup() {\n    let cells = Array(192).fill(null);\n    let disabledCells = [0, 1, 2, 3, 4, 7, 8, 9, 10, 11, 12, 13, 22, 23, 24, 35, 156, 167, 168, 169, 178, 179, 180, 181, 182, 183, 184, 187, 188, 189, 190, 191];\n    let blackKnights = [62, 69, 75, 80];\n    let blackPawns = [63, 64, 65, 66, 67, 68, 76, 77, 78, 79];\n    let whiteKnights = [111, 116, 122, 129];\n    let whitePawns = [112, 113, 114, 115, 123, 124, 125, 126, 127, 128];\n    for (let i = 0; i < disabledCells.length; i++) {\n        cells[disabledCells[i]] = false;\n    }\n    for (let i = 0; i < blackKnights.length; i++) {\n        cells[blackKnights[i]] = pieces.BLACK_KNIGHT;\n    }\n    for (let i = 0; i < blackPawns.length; i++) {\n        cells[blackPawns[i]] = pieces.BLACK_PAWN;\n    }\n    for (let i = 0; i < whiteKnights.length; i++) {\n        cells[whiteKnights[i]] = pieces.WHITE_KNIGHT;\n    }\n    for (let i = 0; i < whitePawns.length; i++) {\n        cells[whitePawns[i]] = pieces.WHITE_PAWN;\n    }\n    return cells;\n}\n\nconst CamelotGame = Game({\n    setup: () => {\n        let cells = getCellsSetup();\n        return {\n            cells: cells,\n            whiteCastleMoves: 0,\n            blackCastleMoves: 0,\n        }\n    },\n\n    moves: {\n        movePiece(G, ctx, pieceGridID, destinationGridID) {\n            G.mustCaptureError = false;\n            let mockProps = {G: G, playerID: ctx.currentPlayer};\n            if (G.movingPieceGridID !== null && pieceGridID !== G.movingPieceGridID) { // enforce moving only one piece in a turn\n                return;\n            }\n            if (G.cells[destinationGridID] !== null || !isMyPiece(mockProps, pieceGridID)) { // can only move own pieces onto vacant squares\n                return;\n            }\n            let destCellInfo = getCellInfo(mockProps, pieceGridID, destinationGridID);\n            if (!destCellInfo.isLegalOption) {\n                return;\n            }\n            let pieceToMove = G.cells[pieceGridID];\n            G.cells[destinationGridID] = pieceToMove;\n            G.cells[pieceGridID] = null;\n            if (destCellInfo.isJumpOption) {\n                G.jumpPositions.push(pieceGridID);\n            }\n            if (destCellInfo.capturedGridID !== false) {\n                G.capturesThisTurn++;\n                G.cells[destCellInfo.capturedGridID] = null;\n            }\n            if (destCellInfo.capturedGridID !== false) {\n                G.moveType = 'Capturing';\n            } else if (destCellInfo.isJumpOption) {\n                G.moveType = 'Jumping';\n            } else {\n                G.moveType = 'Basic';\n            }\n            if (G.moveType === 'Jumping' && (pieceToMove === pieces.BLACK_KNIGHT || pieceToMove === pieces.WHITE_KNIGHT)) {\n                // if this is a knight and the knight is jumping, and the knight comes across an opportunity to start capturing,\n                // then the knight must begin capturing.\n                // We will set a flag here to explain this to the user if needed.\n                // We use the OR here because we don't want to accidentally set these back to false if they were ever previously set.\n                let canStartCharge = canCapture(mockProps, destinationGridID);\n                G.canCaptureThisTurn = G.canCaptureThisTurn || canStartCharge;\n                G.missedKnightsCharge = G.missedKnightsCharge || canStartCharge;\n            }\n            if (ctx.currentPlayer === \"0\") {\n                if (pieceGridID === 5 && destinationGridID === 6 || pieceGridID === 6 && destinationGridID === 5) {\n                    G.whiteCastleMoves++;\n                }\n            } else {\n                if (pieceGridID === 185 && destinationGridID === 186 || pieceGridID === 186 && destinationGridID === 185) {\n                    G.blackCastleMoves++;\n                }\n            }\n            G.movingPieceGridID = destinationGridID;\n            G.mustLeaveCastle = isInOwnCastle(mockProps);\n        },\n        submitTurn(G, ctx) {\n            let mockProps = {G: G, playerID: ctx.currentPlayer};\n            let canEndTurn = true;\n            if (G.canCaptureThisTurn) {\n                if (G.mustLeaveCastle && G.canCaptureOutOfOwnCastle && G.capturesThisTurn < 1) {\n                    G.mustCaptureError = true;\n                    canEndTurn = false;\n                    G.captureOutOfCastle = true;\n                } else {\n                    if (G.capturesThisTurn < 1) {\n                        G.mustCaptureError = true;\n                        canEndTurn = false;\n                    }\n                }\n            }\n            // need to check for *current* possible captures\n            let movingPiece = G.cells[G.movingPieceGridID];\n            if (G.moveType !== 'Basic' && canCapture(mockProps, G.movingPieceGridID)) {\n                if (movingPiece === pieces.BLACK_KNIGHT || movingPiece === pieces.WHITE_KNIGHT) {\n                    // if it's a knight there's no excuse\n                    G.mustCaptureError = true;\n                    canEndTurn = false;\n                } else {\n                    if (G.moveType === 'Capturing') {\n                        // if it's a pawn, and it was capturing, it must continue capturing now\n                        // but if it wasn't already capturing then it was jumping, and it just happened to land here\n                        G.mustCaptureError = true;\n                        canEndTurn = false;\n                    }\n                }\n            }\n            if (canEndTurn) {\n                ctx.events.endTurn();\n            }\n        }\n    },\n\n    flow: {\n        endTurn: false,\n        endPhase: false,\n        onTurnBegin: (G, ctx) => {\n            let mockProps = {G: G, playerID: ctx.currentPlayer};\n            G.moveType = false;\n            G.capturesThisTurn = 0;\n            G.movingPieceGridID = null; // will keep track of the piece that's being moved so no other piece may be moved once it starts moving\n            G.jumpPositions = [];\n            G.canCaptureThisTurn = canCaptureScan(mockProps);\n            G.missedKnightsCharge = false;\n            G.mustCaptureError = false;\n            G.mustLeaveCastle = isInOwnCastle(mockProps);\n            G.canCaptureOutOfOwnCastle = canCaptureOutOfOwnCastle(mockProps);\n            G.canCaptureOutOfCastleThisTurn = canCaptureOutOfOwnCastle(mockProps); // in case the player wants to do a knight's charge out of their castle\n        },\n        onTurnEnd: (G, ctx) => {\n            let wcA = G.cells[185];\n            let wcB = G.cells[186];\n            let bcA = G.cells[5];\n            let bcB = G.cells[6];\n            let blackPieces = [pieces.BLACK_PAWN, pieces.BLACK_KNIGHT];\n            let whitePieces = [pieces.WHITE_PAWN, pieces.WHITE_KNIGHT];\n\n            if (whitePieces.includes(bcA) && whitePieces.includes(bcB)) {\n                // white has taken over the black castle and wins!\n                ctx.events.endGame({ winner: \"0\" })\n            }\n            if (blackPieces.includes(wcA) && blackPieces.includes(wcB)) {\n                // black has taken over the white castle and wins!\n                ctx.events.endGame({ winner: \"1\" })\n            }\n\n            let countBlackPieces = G.cells.filter(obj => blackPieces.includes(obj)).length;\n            let countWhitePieces = G.cells.filter(obj => whitePieces.includes(obj)).length;\n\n            if (countBlackPieces <= 1 && countWhitePieces <= 1) { // DRAWWWWW\n                ctx.events.endGame({ winner: false });\n            } else if (countBlackPieces <= 1) {\n                ctx.events.endGame({ winner: \"0\" });\n            } else if (countWhitePieces <= 1) {\n                ctx.events.endGame({ winner: \"1\" });\n            }\n        },\n    },\n});\n\nexport default CamelotGame;\nexport { pieces, basicOffsets };\n","import React from 'react';\n\nimport BlackKnight from './pieces/BlackKnight.png';\nimport WhiteKnight from './pieces/WhiteKnight.png';\nimport BlackPawn from './pieces/BlackPawn.png';\nimport WhitePawn from './pieces/WhitePawn.png';\nimport CastleIcon from './img/castle.png';\n\nimport { pieces } from './Game.js'\n\nimport { getCellInfo } from './functions.js'\n\nclass CamelotBoard extends React.Component {\n    state = {\n        chosenPiece: null,\n        cellLabels: false,\n        manualFlipBoard: false,\n    }\n\n    undoClick() {\n        this.setState({ chosenPiece: null });\n        this.props.undo();\n    }\n\n    submitTurnClick() {\n        this.setState({ chosenPiece: null });\n        this.props.moves.submitTurn();\n    }\n\n    onClick(gridID) {\n        if (this.props.ctx.currentPlayer !== this.props.playerID) {\n            return;\n        }\n        let cellInfo = getCellInfo(this.props, this.state.chosenPiece, gridID)\n        let cellContent = this.props.G.cells[gridID];\n        if (cellContent === false) {\n            return;\n        }\n        if (cellInfo.isMyPiece) {\n            let moving = this.props.G.movingPieceGridID;\n            if (moving !== null) {\n                this.setState({ chosenPiece: moving });\n            } else {\n                if (!cellInfo.isSelected) {\n                    this.setState({ chosenPiece: gridID });\n                } else {\n                    this.setState({ chosenPiece: null });\n                }\n            }\n        } else if (cellInfo.isLegalOption) {\n            this.props.moves.movePiece(this.state.chosenPiece, gridID);\n            this.setState({ chosenPiece: gridID });\n        }\n    }\n\n    getCellStyle(gridID) {\n        let cellInfo = getCellInfo(this.props, this.state.chosenPiece, gridID);\n\n        let bg = cellInfo.isDarkSquare ? evenColor : oddColor;\n        if (cellInfo.isSelected) {\n            bg = chosenColor;\n        } else if (cellInfo.isLegalOption) {\n            bg = legalColor;\n        }\n\n        let isMyTurn = this.props.ctx.currentPlayer === this.props.playerID;\n        return {\n            textAlign: 'center',\n            verticalAlign: 'middle',\n            position: 'relative',\n            width: cellSize,\n            height: cellSize,\n            backgroundColor: bg,\n            outline: (cellInfo.isSelected ? '2px solid #ff0' : 'none'),\n            zIndex: (cellInfo.isSelected ? '1' : '0'),\n            cursor: (isMyTurn && (cellInfo.isMyPiece || cellInfo.isLegalOption) ? 'pointer' : 'default')\n        };\n    }\n\n    render() {\n        let isMyTurn = this.props.playerID === this.props.ctx.currentPlayer;\n        let amISpectating = this.props.playerID !== \"0\" && this.props.playerID !== \"1\";\n        let tbody = [];\n        for (let i = 0; i < 16; i++) {\n            let cells = [];\n            for (let j = 0; j < 12; j++) {\n                let gridID = (12 * i) + j;\n                let cellContent = this.props.G.cells[gridID];\n\n                if (cellContent === false) { // not on the actual game board--disabled/white cells\n                    cells.push(<td key={gridID} style={{ width: cellSize, height: cellSize }}></td>);\n                    continue;\n                }\n\n                let gridColLetter = ['A','B','C','D','E','F','G','H','I','J','K','L'][j];\n                let gridRowNumber = 16 - i;\n\n                let pieceImg = null;\n                if (cellContent === pieces.BLACK_KNIGHT) {\n                    pieceImg = <img alt=\"Black Knight\" style={pieceStyle} src={BlackKnight}/>;\n                } else if (cellContent === pieces.WHITE_KNIGHT) {\n                    pieceImg = <img alt=\"White Knight\" style={pieceStyle} src={WhiteKnight}/>;\n                } else if (cellContent === pieces.BLACK_PAWN) {\n                    pieceImg = <img alt=\"Black Pawn\" style={pieceStyle} src={BlackPawn}/>;\n                } else if (cellContent === pieces.WHITE_PAWN) {\n                    pieceImg = <img alt=\"White Pawn\" style={pieceStyle} src={WhitePawn}/>;\n                } else {\n                    if ([5, 6, 185, 186].includes(gridID)) {\n                        pieceImg = <img alt=\"Castle\" style={castleStyle} src={CastleIcon}/>;\n                    }\n                }\n\n                let label = this.state.cellLabels ? <span style={labelStyle}>{gridColLetter} {gridRowNumber}</span> : null;\n                cells.push(\n                    <td key={gridID} style={this.getCellStyle(gridID)} onClick={ () => this.onClick(gridID) }>\n                        {label}\n                        {pieceImg}\n                    </td>\n                )\n            }\n            if ((!this.state.manualFlipBoard && this.props.playerID === \"1\") || (this.state.manualFlipBoard && this.props.playerID !== \"1\")) {\n                cells.reverse();\n            }\n            tbody.push(<tr key={\"row-\" + i}>{cells}</tr>);\n        }\n        if ((!this.state.manualFlipBoard && this.props.playerID === \"1\") || (this.state.manualFlipBoard && this.props.playerID !== \"1\")) {\n            tbody.reverse();\n        }\n\n        let messageDiv = null;\n        if (this.props.ctx.gameover) {\n            let winner = this.props.ctx.gameover.winner;\n            if (winner === false) {\n                messageDiv = <div style={messageDivStyle}>GAME OVER! It's a draw!</div>\n            } else {\n                if (winner === \"0\") {\n                    messageDiv = <div style={messageDivStyle}>GAME OVER! White wins!</div>\n                } else {\n                    messageDiv = <div style={messageDivStyle}>GAME OVER! Black wins!</div>\n                }\n            }\n        } else {\n            if (this.props.G.mustCaptureError && isMyTurn) {\n                if (this.props.G.capturesThisTurn === 0) {\n                    if (this.props.G.missedKnightsCharge) {\n                        messageDiv = <div style={messageDivStyle}>Your Knight missed a Knight's Charge opportunity along this path.</div>\n                    } else if (this.props.G.canCaptureOutOfCastleThisTurn) {\n                        messageDiv = <div style={messageDivStyle}>You must capture out of your Castle this turn.</div>\n                    } else {\n                        messageDiv = <div style={messageDivStyle}>You must capture this turn.</div>\n                    }\n                } else {\n                    messageDiv = <div style={messageDivStyle}>You must continue capturing until no more captures are possible.</div>\n                }\n            }\n        }\n        if (amISpectating) {\n            let whoseTurnDiv = <div style={{ marginTop: '20px' }}><strong>{this.props.ctx.currentPlayer === \"0\" ? \"White's Turn\" : \"Black's Turn\"}</strong></div>\n            if (this.props.ctx.gameover) {\n                whoseTurnDiv = messageDiv;\n            }\n            return (\n                <div style={gameWrapStyle}>\n                    {whoseTurnDiv}\n                    <table cellSpacing=\"0\" id=\"board\">\n                        <tbody>{tbody}</tbody>\n                    </table>\n                    <div style={buttonsStyle}>\n                        <button onClick={ () => this.setState({ cellLabels: !this.state.cellLabels }) } style={toggleLabelsStyle}>Toggle Labels</button>\n                        <button onClick={ () => this.setState({ manualFlipBoard: !this.state.manualFlipBoard }) } style={toggleLabelsStyle}>Flip Board</button>\n                    </div>\n                </div>\n            );\n        }\n        let canSubmit = isMyTurn && !messageDiv && this.props.G.moveType !== false;\n        let buttonsDiv = (\n            <div style={buttonsStyle}>\n                <button onClick={ () => this.undoClick() } style={undoStyle} disabled={!isMyTurn}>Undo</button>\n                <button onClick={ () => this.submitTurnClick() } style={submitTurnButtonStyle} disabled={!canSubmit}>Submit Turn</button>\n                <button onClick={ () => this.setState({ cellLabels: !this.state.cellLabels }) } style={toggleLabelsStyle}>Toggle Labels</button>\n                <button onClick={ () => this.setState({ manualFlipBoard: !this.state.manualFlipBoard }) } style={toggleLabelsStyle}>Flip Board</button>\n            </div>\n        );\n        let whoseTurnDiv = <div style={{ margin: '20px 0px' }}><strong>{isMyTurn ? \"My Turn\" : \"Opponent's Turn\"}</strong></div>\n        if (this.props.ctx.gameover) {\n            whoseTurnDiv = null;\n            buttonsDiv = (\n                <div style={buttonsStyle}>\n                    <button onClick={ () => this.props.reset() } style={submitTurnButtonStyle}>Reset Game</button>\n                    <button onClick={ () => this.setState({ cellLabels: !this.state.cellLabels }) } style={toggleLabelsStyle}>Toggle Labels</button>\n                    <button onClick={ () => this.setState({ manualFlipBoard: !this.state.manualFlipBoard }) } style={toggleLabelsStyle}>Flip Board</button>\n                </div>\n            );\n        }\n        return (\n            <div style={gameWrapStyle}>\n                {messageDiv}\n                <table cellSpacing=\"0\" id=\"board\">\n                    <tbody>{tbody}</tbody>\n                </table>\n                {whoseTurnDiv}\n                {buttonsDiv}\n            </div>\n        );\n    }\n}\n\nexport default CamelotBoard;\n\nconst oddColor = '#ce9c4b';\nconst evenColor = '#e0c18f';\nconst chosenColor = '#cb0';\nconst legalColor = '#9c9';\nconst cellSize = '35px';\n\nconst gameWrapStyle = {\n    display: 'flex',\n    flexDirection: 'column',\n    alignItems: 'center',\n    justifyContent: 'center',\n    marginTop: '20px'\n}\nconst messageDivStyle = {\n    textAlign: 'center',\n    width: '500px',\n    padding: '20px',\n    fontWeight: 'bold',\n}\nconst buttonsStyle = {\n    display: 'flex',\n    justifyContent: 'center',\n    width: '100%',\n    padding: '20px 0px',\n}\nconst submitTurnButtonStyle = {\n    width: '200px',\n    height: '50px',\n    backgroundColor: '#d0d0d0',\n    border: '1px solid #ccc',\n    borderRadius: '3px',\n    cursor: 'pointer',\n    margin: '0px 10px'\n}\nconst undoStyle = {\n    width: '80px',\n    height: '50px',\n    backgroundColor: '#d0d0d0',\n    border: '1px solid #ccc',\n    borderRadius: '3px',\n    cursor: 'pointer',\n    margin: '0px 10px'\n}\nconst toggleLabelsStyle = {\n    width: '120px',\n    height: '50px',\n    backgroundColor: '#d0d0d0',\n    border: '1px solid #ccc',\n    borderRadius: '3px',\n    cursor: 'pointer',\n    margin: '0px 10px'\n}\nconst pieceStyle = {\n    width: '80%',\n    height: '80%',\n};\nconst castleStyle = {\n    width: '75%',\n    height: '75%',\n    filter: 'invert(.8) drop-shadow(0px 0px 1px rgba(0, 0, 0, 0.25)) sepia(70%)'\n};\nconst labelStyle = {\n    position: 'absolute',\n    top: '2px',\n    left: '2px',\n    fontSize: '8px',\n    color: 'rgba(0, 0, 0, 0.3)',\n    fontWeight: 'bold',\n    fontFamily: 'monospace',\n};\n","import React from 'react';\n\nimport { Client } from 'boardgame.io/react';\n\nimport CamelotGame from './Game.js'\nimport CamelotBoard from './Board.js';\nimport { BrowserRouter as Router, Route, Link } from \"react-router-dom\";\n\nconst CamelotClient = Client({\n    game: CamelotGame,\n    board: CamelotBoard,\n    debug: process.env.NODE_ENV === 'development',\n    multiplayer: { server: process.env.REACT_APP_SERVER },\n});\n\nconst App = () => (\n    <Router>\n        <div>\n            <Route path=\"/\" exact render={ () => (\n                <div style={{ padding: '10px' }}>\n                    <Link to=\"/white\">Play as white.</Link>\n                    <br />\n                    <Link to=\"/black\">Play as black.</Link>\n                    <br />\n                    <Link to=\"/spectate\">Spectate.</Link>\n                </div>\n            )} />\n            <Route path=\"/spectate\" render={ () => (\n                <CamelotClient />\n            )} />\n            <Route path=\"/white\" render={ () => (\n                <CamelotClient playerID=\"0\" />\n            )} />\n            <Route path=\"/black\" render={ () => (\n                <CamelotClient playerID=\"1\" />\n            )} />\n        </div>\n    </Router>\n)\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read http://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit http://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See http://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: http://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}